import collections
from typing import List

#최대 n개의 코스가 있고 그중 선행 코스가 존재한다 그 코스가 무한순환이냐 아니냐 체크하는 문제 무한순환이면 =False
#ex> n= 4 / [0,1][1,2] True 1->0 2->1
#ex> n= 5 / [0,5][1,5] True
#[1,0][0,1]

class Solution:
    def canFinish\
    (self, numCourses: int, prerequisites: List[List[int]]) \
            -> bool:
        # graph = collections.defaultdict(list)
        # # 그래프 구성
        # for x, y in prerequisites:
        #     graph[x].append(y)
        #
        # visit = set()           #순환 목적으로 방문을 체크
        # visit2 = set()          #정말 단순 방문을 체크 b : 악질....
        #
        # def fun(i):
        #     if i in visit:
        #         return False
        #     if i in visit2:
        #         return True
        #
        #     visit.add(i)
        #     for j in graph[i]:
        #         if not fun(j):
        #             return False
        #     visit.remove(i)     #연관된 수가 나오면 방문으로 체크할수있어서 지워줌
        #     visit2.add(i)       #단순 방문 체크목적이므로 remove를 체크하지않음
        #     return True
        #
        # for x in list(graph):           #이중배열 표현
        #     if not fun(x):
        #         return False
        #
        # return True

        # [[2,3],[0,3]]
        indegree = [0] * numCourses     #순환 체크용 값 입력
        for pre in prerequisites:
            indegree[pre[0]] += 1  # add preq num

        graph = collections.defaultdict(list)   #그래프 작성
        for pre in prerequisites:
            if pre[1] not in graph:
                graph[pre[1]] = []
            graph[pre[1]].append(pre[0])


        q = collections.deque() #순환
        for i in range(numCourses):
            if indegree[i]==0:
                q.append(i)

        while len(q)>0: #순환처리
            cur = q.popleft()
            totakes = graph[cur]
            for course in totakes:
                indegree[course] -=1
                if indegree[course] ==0:
                    q.append(course)

        for i in range(numCourses):     #순환 여부 체크
            if indegree[i]!=0:
                return False
        return True

        print("asdf")

s =Solution()

# print(s.canFinish(2,[[1,0]]))
# print(s.canFinish(2,[[1,0],[0,1]]))
print(s.canFinish(4,[[2,3],[0,3]]))
# print(s.canFinish(100,[[1,0],[2,0],[2,1],[3,1],[3,2],[4,2],[4,3],[5,3],[5,4],[6,4],[6,5],[7,5],[7,6],[8,6],[8,7],[9,7],[9,8],[10,8],[10,9],[11,9],[11,10],[12,10],[12,11],[13,11],[13,12],[14,12],[14,13],[15,13],[15,14],[16,14],[16,15],[17,15],[17,16],[18,16],[18,17],[19,17],[19,18],[20,18],[20,19],[21,19],[21,20],[22,20],[22,21],[23,21],[23,22],[24,22],[24,23],[25,23],[25,24],[26,24],[26,25],[27,25],[27,26],[28,26],[28,27],[29,27],[29,28],[30,28],[30,29],[31,29],[31,30],[32,30],[32,31],[33,31],[33,32],[34,32],[34,33],[35,33],[35,34],[36,34],[36,35],[37,35],[37,36],[38,36],[38,37],[39,37],[39,38],[40,38],[40,39],[41,39],[41,40],[42,40],[42,41],[43,41],[43,42],[44,42],[44,43],[45,43],[45,44],[46,44],[46,45],[47,45],[47,46],[48,46],[48,47],[49,47],[49,48],[50,48],[50,49],[51,49],[51,50],[52,50],[52,51],[53,51],[53,52],[54,52],[54,53],[55,53],[55,54],[56,54],[56,55],[57,55],[57,56],[58,56],[58,57],[59,57],[59,58],[60,58],[60,59],[61,59],[61,60],[62,60],[62,61],[63,61],[63,62],[64,62],[64,63],[65,63],[65,64],[66,64],[66,65],[67,65],[67,66],[68,66],[68,67],[69,67],[69,68],[70,68],[70,69],[71,69],[71,70],[72,70],[72,71],[73,71],[73,72],[74,72],[74,73],[75,73],[75,74],[76,74],[76,75],[77,75],[77,76],[78,76],[78,77],[79,77],[79,78],[80,78],[80,79],[81,79],[81,80],[82,80],[82,81],[83,81],[83,82],[84,82],[84,83],[85,83],[85,84],[86,84],[86,85],[87,85],[87,86],[88,86],[88,87],[89,87],[89,88],[90,88],[90,89],[91,89],[91,90],[92,90],[92,91],[93,91],[93,92],[94,92],[94,93],[95,93],[95,94],[96,94],[96,95],[97,95],[97,96],[98,96],[98,97],[99,97]]))

